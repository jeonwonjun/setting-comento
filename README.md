SETTING Database

1. 오류
IntelliJ에서 mongoDB가 아니라 mysql로 연결하려고 하는데 데이터베이스 연결에 실패합니다.

2. 오류 과정
- 우선 처음에는 의존성 및 datasource.xml파일의 문제였어서 해당 코드를 다시 수정했습니다.
- 이후에 #1-4 결과값을 구하기 위해 mysql에 statistic 스키마를 설정하고 sample 데이터베이스를 만들어서 샘플 값들을 입력하였습니다.
- 하지만 localhost:9080/requests에 접속했을 때 아래와 같은 오류가 나와 데이터베이스에 연결되지 않았습니다.

- 처음에는 acess denied for user 'admin'@'172.18.0.1'(using password: YES) 오류가 나와서
  
CREATE USER 'admin'@'172.18.0.1' IDENTIFIED BY 'admin';

GRANT ALL PRIVILEGES ON statistic.* TO 'admin'@'172.18.0.1';

FLUSH PRIVILEGES;
로 비밀번호 재설정 및 권한부여를 했는데 맞게 한지 잘 모르겠습니다. 현재 최종 오류 상태 아래 첨부하겠습니다.

-------------------------------------------------------------------------------------------------------------------------------------------
# 2주차 과제 - REST API가 무엇인가?

## REST & REST API
- REST: "REpresentational State Transfer" 의 약자로, 자원을 이름(자원의 표현)으로 구분해 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미

### REST API란?
- REST의 특징을 기반으로 서비스 API를 구현한 것
- 특징: REST API의 가장 큰 특징은 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능한 것
- REST API는 URI는 정보의 자원만 표현해야 하며, 자원의 행위는 HTTP Method에 명시해야한다.

## HTTP 통신
- HTTP에서는 __클라이언트가 서버에 요청 메시지를 보내고 서버는 클라이언트의 요청에 대한 응답을 반환.__ 연결 상태를 유지하지 않는 비연결성 프로토콜이며, 요청과 응답(request, response) 방식으로 동작
- 비연결성 프로토콜이라는 말은 서버는 응답 메시지를 반환한 후에 클라이언트의 상태를 저장하지 않는다는 것이다. (= 무상태성(stateless))
- 무상태성은 데이터를 주고받기 위한 각각의 데이터 요청이 서로 독립적으로 관리된다. 이전 데이터 요청과 다음 데이터 요청이 서로 관련 없음.

### HTTP 프로토콜 차이점
- HTTP/1: TCP/IP
- HTTP/2: TCP/IP → 텍스트 형식 대신, 바이너리 데이터를 교환. 또한, 서버가 새 HTTP 요청을 기다리는 대신, 클라이너트 캐시에 응답을 사전에 전송할 수 있다.
- HTTP/3: QUIC → HTTP/2 발전 버전. 목표는 실시간 스트리밍 및 기타 최신 데이터 전송 요구사항을 보다 효율적으로 지원

### HTTPS
- HTTP + Secure(TLS/SSL)
- 현재 HTTP/2 사용

## URL 작동 과정
1. 웹 브라우저에 URL을 입력하고 Enter키 입력
   
  ex) https://github.com/jeonwonjun → 프로토콜(https://) / 도메인(github.com) / 경로(jeonwonjun) / 리소스

2. 웹 브라우저가 도메인명의 IP 주소 조회(먼저 캐시 조회, 그 다음 DNS 검색)
    - DNS는 복잡하고 매우 빨라야 하기 때문에 DNS 데이터는 웹 브라우저 사이의 서로 다른 계층과 인터넷의 다양한 위치에 임시로 저장. = 캐시(Cache)
    - 캐시 검색 순서: 웹 브라우저 캐시 → 운영체제 캐시 → 라우터 캐시 → ISP 캐시

3. 웹 브라우저가 찾은 IP 주소를 기반으로 서버와의 TCP 연결을 시작
    - TCP 연결 방식(THREE-WAY HANDSHAKE)

5. 웹 브라우저가 HTTP요청을 서버로 전송(필요한 경우, HTTPS 보안 통신 진행) = Request
    - HTTP 요청 메시지를 생성하여 웹 서버로 전송
    - 요청 메시지: 요청 방식(GET, POST 등), 헤더, 쿠키, 요청 바디 등
  
6. 웹 서버가 요청을 처리하고 응답을 다시 웹 브라우저로 전송 = Response
   - 브라우저로부터 받은 요청에 대한 응답을 생성하여 전송
   - 응답 메시지: HTTP 상태 코드, 헤더, 쿠키, 응답 본문 등

8. 웹 브라우저가 전송 받은 콘텐츠 렌더링
    - HTML, CSS, JavaScript 등의 리소스를 해석
